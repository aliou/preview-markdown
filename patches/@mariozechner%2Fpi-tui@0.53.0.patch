diff --git a/node_modules/@mariozechner/pi-tui/.bun-tag-750ab9af57692216 b/.bun-tag-750ab9af57692216
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/dist/components/markdown.js b/dist/components/markdown.js
index e5dec586d755d1ec592fd7a929792e82d4c38bde..c966f01715a2f01339a4f97548bef0b8ac241162 100644
--- a/dist/components/markdown.js
+++ b/dist/components/markdown.js
@@ -172,6 +172,40 @@ export class Markdown {
             stylePrefix: this.getDefaultStylePrefix(),
         };
     }
+    /**
+     * Render a code block between separator lines.
+     * Top separator keeps optional language label.
+     */
+    renderCodeBlock(code, lang, availableWidth) {
+        const lines = [];
+        const codeWidth = Math.max(1, availableWidth);
+        const innerPad = codeWidth >= 4 ? 1 : 0;
+        const innerWidth = Math.max(1, codeWidth - innerPad * 2);
+        const makeSeparator = (label) => {
+            const prefix = label ? `─ ${label} ` : "";
+            const fill = "─".repeat(Math.max(0, codeWidth - visibleWidth(prefix)));
+            return this.theme.codeBlockBorder(prefix + fill);
+        };
+        lines.push(makeSeparator(lang));
+        let codeLines;
+        if (this.theme.highlightCode) {
+            codeLines = this.theme.highlightCode(code, lang);
+        }
+        else {
+            codeLines = code.split("\n");
+        }
+        for (const codeLine of codeLines) {
+            const wrapped = wrapTextWithAnsi(codeLine, innerWidth);
+            for (const wrappedLine of wrapped) {
+                const innerPadding = " ".repeat(Math.max(0, innerWidth - visibleWidth(wrappedLine)));
+                const paddedInner = wrappedLine + innerPadding;
+                const paddedLine = " ".repeat(innerPad) + paddedInner + " ".repeat(innerPad);
+                lines.push(this.theme.codeBlock(paddedLine));
+            }
+        }
+        lines.push(makeSeparator(""));
+        return lines;
+    }
     renderToken(token, width, nextTokenType) {
         const lines = [];
         switch (token.type) {
@@ -205,29 +239,15 @@ export class Markdown {
                 break;
             }
             case "code": {
-                const indent = this.theme.codeBlockIndent ?? "  ";
-                lines.push(this.theme.codeBlockBorder(`\`\`\`${token.lang || ""}`));
-                if (this.theme.highlightCode) {
-                    const highlightedLines = this.theme.highlightCode(token.text, token.lang);
-                    for (const hlLine of highlightedLines) {
-                        lines.push(`${indent}${hlLine}`);
-                    }
-                }
-                else {
-                    // Split code by newlines and style each line
-                    const codeLines = token.text.split("\n");
-                    for (const codeLine of codeLines) {
-                        lines.push(`${indent}${this.theme.codeBlock(codeLine)}`);
-                    }
-                }
-                lines.push(this.theme.codeBlockBorder("```"));
+                const codeBlockLines = this.renderCodeBlock(token.text, token.lang, width);
+                lines.push(...codeBlockLines);
                 if (nextTokenType !== "space") {
                     lines.push(""); // Add spacing after code blocks (unless space token follows)
                 }
                 break;
             }
             case "list": {
-                const listLines = this.renderList(token, 0);
+                const listLines = this.renderList(token, 0, width);
                 lines.push(...listLines);
                 // Don't add spacing after lists if a space token follows
                 // (the space token will handle it)
@@ -364,7 +384,7 @@ export class Markdown {
     /**
      * Render a list with proper nesting support
      */
-    renderList(token, depth) {
+    renderList(token, depth, availableWidth) {
         const lines = [];
         const indent = "  ".repeat(depth);
         // Use the list's start property (defaults to 1 for ordered lists)
@@ -373,7 +393,8 @@ export class Markdown {
             const item = token.items[i];
             const bullet = token.ordered ? `${startNumber + i}. ` : "- ";
             // Process item tokens to handle nested lists
-            const itemLines = this.renderListItem(item.tokens || [], depth);
+            const itemContentWidth = Math.max(1, availableWidth - visibleWidth(indent) - 2);
+            const itemLines = this.renderListItem(item.tokens || [], depth, itemContentWidth);
             if (itemLines.length > 0) {
                 // First line - check if it's a nested list
                 // A nested list will start with indent (spaces) followed by cyan bullet
@@ -411,13 +432,13 @@ export class Markdown {
      * Render list item tokens, handling nested lists
      * Returns lines WITHOUT the parent indent (renderList will add it)
      */
-    renderListItem(tokens, parentDepth) {
+    renderListItem(tokens, parentDepth, availableWidth) {
         const lines = [];
         for (const token of tokens) {
             if (token.type === "list") {
                 // Nested list - render with one additional indent level
                 // These lines will have their own indent, so we just add them as-is
-                const nestedLines = this.renderList(token, parentDepth + 1);
+                const nestedLines = this.renderList(token, parentDepth + 1, availableWidth);
                 lines.push(...nestedLines);
             }
             else if (token.type === "text") {
@@ -432,21 +453,8 @@ export class Markdown {
             }
             else if (token.type === "code") {
                 // Code block in list item
-                const indent = this.theme.codeBlockIndent ?? "  ";
-                lines.push(this.theme.codeBlockBorder(`\`\`\`${token.lang || ""}`));
-                if (this.theme.highlightCode) {
-                    const highlightedLines = this.theme.highlightCode(token.text, token.lang);
-                    for (const hlLine of highlightedLines) {
-                        lines.push(`${indent}${hlLine}`);
-                    }
-                }
-                else {
-                    const codeLines = token.text.split("\n");
-                    for (const codeLine of codeLines) {
-                        lines.push(`${indent}${this.theme.codeBlock(codeLine)}`);
-                    }
-                }
-                lines.push(this.theme.codeBlockBorder("```"));
+                const codeBlockLines = this.renderCodeBlock(token.text, token.lang, availableWidth);
+                lines.push(...codeBlockLines);
             }
             else {
                 // Other token types - try to render as inline
